#include "alien_manager.h"#include "alien.h"#include <stdlib.h>#include <stdio.h>#include <allegro5/allegro.h>#include <allegro5/allegro_primitives.h>#include "bullet_manager.h"#include "bullet.h" #include "sound_manager.h"#include "animator.h"#include "screen_config.h"#include <math.h>#define TOXIC_ALIEN_SPRITE_PATH "../assets/images/sprites/alien/toxic_alien.png"#define RAGE_ALIEN_SPRITE_PATH "../assets/images/sprites/alien/rage_alien.png"#define SPOOKY_ALIEN_SPRITE_PATH "../assets/images/sprites/alien/spooky_alien.png"#define ALIEN_BULLET_SPRITE_PATH "../assets/images/sprites/alien/alien_bullet.png"#define ALIEN_WIDTH 40#define ALIEN_HEIGHT 40#define ALIEN_SPEED 12  #define ALIEN_DES_STEP 40#define ALIEN_HORIZONTAL_GAP 20#define ALIEN_VERTICAL_GAP 30#define MAX_BULLETS 5#define FIRE_PROBABILITY .02f/// Configuração padrão para todas as balas dos aliens.const BulletConfig ALIEN_BULLET_CONFIG = {    .width = 5.0f,    .height = 18.0f,    .speed = 12.0f,    .move_dir = MOVE_DOWN,    .is_active = false,    .color = (RGB) {.red = 255, .green = 45, .blue = 0}, };/** * @brief Retorna uma estrura AlienConfig para cada tipo de alien.  *      * @param type O tipo de alien que se deseja obter a configuração. */AlienConfig get_alien_config(AlienType type) {    AlienConfig basic_config = {        (Point) {.0f, .0f},        .width = ALIEN_WIDTH,        .height = ALIEN_HEIGHT,        .is_alive = false,        .speed = ALIEN_SPEED,        .descent_step = ALIEN_DES_STEP,        .draw_hitbox = false,    };    if (type == TOXIC_ALIEN) {        basic_config.points = 50;        basic_config.color = (RGB) {            .red = 127, .green = 255, .blue = 0};        basic_config.sprite_path = TOXIC_ALIEN_SPRITE_PATH;    }    if (type == RAGE_ALIEN) {        basic_config.points = 30;        basic_config.color = (RGB) {            .red = 255, .green = 45, .blue = 0};        basic_config.sprite_path = RAGE_ALIEN_SPRITE_PATH;    }    if (type == SPOOKY_ALIEN) {        basic_config.points = 10;        basic_config.color = (RGB) {            .red = 18, .green = 174, .blue = 9};        basic_config.sprite_path = SPOOKY_ALIEN_SPRITE_PATH;    }    return basic_config;}/** * @brief Calcula a largura total em pixels do grupo de aliens.  *      * @param columns Número de culunas da formação dos aliens. */float calculate_aliens_group_width(int columns) {    return ALIEN_WIDTH * columns + (ALIEN_HORIZONTAL_GAP * (columns - 1));}/** * @brief Inicializa a estrutura AlienManager. *      * @param manager Ponteiro para o AlienManager. * @param rows Número de linhas da formação dos aliens. * @param columns Número de colunas da formação dos aliens. * @param move_interval Intervalo de tempo do movimento dos aliens. * @param fire_interval Intervalo de tempo do disparo dos aliens. */void init_alien_manager(AlienManager *manager, int rows, int columns, float move_interval,     float fire_interval) {    manager->bm = create_bullet_manager(MAX_BULLETS, ALIEN_BULLET_CONFIG,         get_sprite(ALIEN_BULLET_SPRITE_PATH));    manager->count = rows * columns;    manager->rows = rows;    manager->columns = columns;    manager->mov_dir = MOVE_RIGHT;    manager->move_interval = move_interval;    manager->last_move_time = 0;    manager->alives = 0;    manager->group_width = calculate_aliens_group_width(columns);    manager->fire_probability = FIRE_PROBABILITY;    manager->fire_interval = fire_interval;    manager->last_fire_time = 0;    manager->aliens = (Alien *) malloc(sizeof(Alien) * manager->count);        if (!manager->aliens) {        fprintf(stderr, "Falied to create aliens matrix.\n");        exit(-1);    }}/** * @brief Alloca memoria para a estrura AlienManager e retorna um poteiro para ela. *  * @return AlienManager. */AlienManager *create_alien_manager() {    AlienManager *manager = (AlienManager *) malloc(sizeof(AlienManager));    if (!manager) {        fprintf(stderr, "Failed to create Alien Manager.\n");        exit(-1);    }    return manager;}/** * @brief Retorna um Point que indica em qual posição da tela o grupo de aliens * posicionado.    *  * @param group_width Largura total da formação dos aliens. *  * @return Point representado em qual coordenada o grupo de aliens deve ser colocado. */Point get_alines_spawn_pos(int group_width) {    return (Point) {(SCREEN_WIDTH - group_width) / 2.0f, SCREEN_TOP_MARGIN};}/** * @brief Define o posicionamente de cada alien e troca seu estado logico para vivo .   *  * @param manager Ponteiro para o AlienManager. */void spawn_aliens(AlienManager *manager) {    Point start_pos = get_alines_spawn_pos(manager->group_width);    Point current_pos = start_pos;    for (int i = 0; i < manager->rows; i++) {        Alien *alien;        for (int j = 0; j < manager->columns; j++) {            alien = &manager->aliens[i * manager->columns + j];            manager->alives++;            alien->is_alive = true;            alien->pos = current_pos;            current_pos.x += alien->width + ALIEN_HORIZONTAL_GAP;        }        current_pos.y += alien->height + ALIEN_VERTICAL_GAP;        current_pos.x = start_pos.x;    }}/** * @brief Libera os recursos utilizados pelo AlienManager.   *  * @param manager Ponteiro para o AlienManager. */void destroy_alien_manager(AlienManager *manager) {    if (!manager) return;    for (int i = 0; i < manager->count; i++) {        Alien* alien = &manager->aliens[i];        destroy_alien(alien);    }    if (manager->aliens)         free(manager->aliens);        if (manager->bm)         destroy_bullet_manager(manager->bm);        free(manager);}/** * @breif Verifica um alien atingiu o canto direito da tela. *  * @param x Coordenada horizontal do alien. * @param width Largura do alien. * @param edge_max Coordenada do canto direito da tela.  */bool has_hit_right_edge(int x, int width, int edge_max) {    return x + width > edge_max;}/** * @breif Verifica um alien atingiu o canto esquerdo da tela. *  * @param x Coordenada horizontal do alien. * @param edge_min Coordenada do canto esquerdo da tela.  */bool has_hit_left_edge(int x, int edge_min) {    return x < edge_min;}/** * @breif Verifica se algum alien atingiu os limites da tela. *  * @param manager Ponteiro para o AlienManager. * @param start_x Coordenada horizontal de início. * @param width Comprimento da tela. */bool alien_group_reached_edge(AlienManager *manager, int start_x, int width) {    for (int i = 0; i < manager->count; i++) {        Alien *alien = &manager->aliens[i];        if (!alien->is_alive) continue;        if (manager->mov_dir == MOVE_RIGHT &&             has_hit_right_edge(alien->pos.x, alien->width, width)) {            return true;        }        if (manager->mov_dir == MOVE_LEFT &&             has_hit_left_edge(alien->pos.x, start_x)) {            return true;        }    }    return false;}/** * @breif Move cada alien horizontalmente. *  * @param alien Ponteiro para o alien. * @param mov_dir Direção do movimento (MOVE_LEFT ou MOVE_RIGHT). * @param amount Quantidade pixels a mover. */void move_aliens_horizontal(AlienManager *manager, MoveDir dir, int amount) {     for (int i = 0; i < manager->count; i++) {            Alien *alien = &manager->aliens[i];            if (alien->is_alive)                move_alien_horizontal(alien, dir, amount);        }}/** * @breif Move cada alien verticalmente. *  * @param alien Ponteiro para o alien. * @param mov_dir Direção do movimento (MOVE_UP ou MOVE_DOWN). * @param amount Quantidade pixels a mover. */void move_aliens_vertical(AlienManager *manager, MoveDir dir, int amount) {    for (int i = 0; i < manager->count; i++) {        Alien *alien = &manager->aliens[i];        if (alien->is_alive)             move_alien_vertical(alien, dir, amount);    }            }/** *  * @breif Move o grupo de aliens horizontalmente até que eles colidam com os cantos da tela * então mevo-os verrticalmente e inverte sua direção de movimento horizontal. *  * @param manager Ponteiro para o AlienManager. */void handle_aliens_movement(AlienManager *manager) {    bool transpass_edge = alien_group_reached_edge(manager,             SCREEN_HORIZONTAL_MARGIN, SCREEN_WIDTH - SCREEN_HORIZONTAL_MARGIN);    if (transpass_edge) {        move_aliens_vertical(manager, MOVE_DOWN, ALIEN_DES_STEP);        manager->mov_dir = manager->mov_dir == MOVE_RIGHT ? MOVE_LEFT : MOVE_RIGHT;        return;    }    move_aliens_horizontal(manager, manager->mov_dir, ALIEN_SPEED);    }/** * @breif Retorna uma array the Rect contendo a posição dos aliens vivos.  *  * @param manager Ponteiro para o AlienManager. *  * @return React vector. */Rect *get_alive_aliens_hitbox(AlienManager *manager) {    if (manager->alives == 0) return NULL;    Rect *hitboxes = (Rect *) malloc(sizeof(Rect) * manager->alives);    if (!hitboxes)         return NULL;        Rect *current = hitboxes;    for (int i = 0; i < manager->count; i++) {        Alien *alien = &manager->aliens[i];        if (alien->is_alive) {            *current = get_collider(alien->pos, alien->width, alien->height);            current++;        }    }    return hitboxes;}/** * @breif Libera a memória utilizada para armazenar a array de hitboxes. *  * @param hitboxes Ponteiro para a array de hitboxes. */void free_hitboxes_array(Rect *hitboxes) {    free(hitboxes);}/** * @breif Retorna uma posição de um alien vivo aleatório .  *  * @param manager Ponteiro para AlienManager. *  * @return React representando a hitbox de uma alien. */Rect get_random_alien_hitbox(AlienManager *manager) {    int random_index = random_integer(0, manager->alives - 1);    Rect hitbox = {{-1, -1}, 0, 0};    Rect *hitboxes = get_alive_aliens_hitbox(manager);    if (!hitboxes)         return hitbox;    hitbox = hitboxes[random_index];    free_hitboxes_array(hitboxes);    return hitbox;}/** * @breif Dispara uma projétil a partir da posição de uma alien aleatório  * e toca o som de tiro. *  * @param manager Ponteiro para AlienManager. */void fire(AlienManager *manager) {    Rect hitbox = get_random_alien_hitbox(manager);    if (hitbox.pos.x < 0) return;    fire_bullet(manager->bm, hitbox);    play_sound(SFX_ALIEN_SHOOT);    manager->last_fire_time = al_get_time();}/** * @breif Verifica se o grupo de aliens pode atirar. *  * @param manager Ponteiro para AlienManager. * @param fire_chance Chance de um alien atirar. *  * @return bool  */bool alien_can_fire(AlienManager *manager, float fire_chance) {    double now = al_get_time();    double delta_time = now - manager->last_fire_time;    return fire_chance <= manager->fire_probability &&            manager->bm->quantity < manager->bm->max &&           manager->alives > 0 &&           delta_time >= manager->fire_interval;}/** * @breif Verifica se o grupo de aliens pode atirar, se sim, dispara.  *  * @param manager Ponteiro para AlienManager. */void handle_fire(AlienManager *manager) {    float fire_chance = random_float();    if (alien_can_fire(manager, fire_chance))        fire(manager);}/** * @breif Faz o update do movimento dos aliens, incluido a animação dos aliens e  * dos projéties disparados.  *  * @param manager Ponteiro para AlienManager. */void update_aliens(AlienManager *manager) {    double now = al_get_time();    double delta_time = now - manager->last_move_time;    if (delta_time >= manager->move_interval) {        handle_aliens_movement(manager);        manager->last_move_time = now;    }    for (int i = 0; i < manager->count; i++) {        Alien *alien = &manager->aliens[i];        if (alien->is_alive)            update_animator(alien->animator);    }    update_bullets(manager->bm);    handle_fire(manager);}/** * @breif Verifica se todos os aliens foram mortos. *  * @param manager Ponteiro para AlienManager. *  * @return bool representando se todos os aliens morreram. */bool all_aliens_dead(AlienManager *manager) {    for (int i = 0; i < manager->count; i++) {        if (manager->aliens[i].is_alive)             return false;    }    return true;}/** * @breif Troca o estado lógico do alien para morto, utiliza-se o id . * do alien para isso, nesse caso o id é a sua posição no vetor de aliens. *  * @param manager Ponteiro para AlienManager. * @param id Identificação do alien. */void kill_alien_by_id(AlienManager *manager, int id) {    kill_alien(&manager->aliens[id]);    manager->alives--;}/** * @breif Verifica se o grupo de aliens atingiu uma linha de perigo. *  * @param manager Ponteiro para AlienManager. * @param danger_line_y Coordenada y que se deseja verificar. *  * @return bool definindo se os aliens passaram da danger line. */bool aliens_crossed_threshold(AlienManager *manager, float danger_line_y) {       for (int i = 0; i < manager->count; i++) {            Alien *alien = &manager->aliens[i];            if (!alien->is_alive) continue;            if (alien->pos.y + alien->height >= danger_line_y)                return true;       }    return false;}/** * @breif Desenha os aliens na tela se o alien estiver vivo. *  * @param manager Ponteiro para AlienManager. */void draw_aliens(AlienManager *manager) {    for (int i = 0; i < manager->count; i++) {        Alien *alien = &manager->aliens[i];        if (!alien->is_alive) continue;        draw_alien(alien);    }}